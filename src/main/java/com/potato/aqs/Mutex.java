package com.potato.aqs;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.AbstractQueuedSynchronizer;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;/** * Created by potato on 2017/10/13. */public class Mutex  implements Lock {    //自定义内部同步器实现    private static class Sync extends AbstractQueuedSynchronizer{        @Override        protected boolean isHeldExclusively() {            return getState()==1;        }        @Override        protected boolean tryAcquire(int arg) {            if(compareAndSetState(0,1)){                setExclusiveOwnerThread(Thread.currentThread());                return true;            }            return  false;        }        @Override        protected boolean tryRelease(int arg) {            if(getState()==0)                throw new IllegalMonitorStateException();            setExclusiveOwnerThread(null);            setState(0);            return true;        }        Condition newCondition() { return new ConditionObject(); }    }    private final Sync sync = new Sync();    public void lock() {        sync.acquire(1);    }    public void lockInterruptibly() throws InterruptedException {        sync.acquireInterruptibly(1);    }    public boolean tryLock() {        return sync.tryAcquire(1);    }    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {        return sync.tryAcquireNanos(1,unit.toNanos(time));    }    public Condition newCondition() {        return sync.newCondition();    }    public void unlock() {        sync.release(1);    }}